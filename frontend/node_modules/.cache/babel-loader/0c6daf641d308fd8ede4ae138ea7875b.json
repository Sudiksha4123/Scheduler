{"ast":null,"code":"import _classCallCheck from \"/home/benu/test_calendar/Scheduler/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/benu/test_calendar/Scheduler/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/home/benu/test_calendar/Scheduler/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/benu/test_calendar/Scheduler/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/benu/test_calendar/Scheduler/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nif (!window['Smart']) {\n  window['Smart'] = {\n    RenderMode: 'manual'\n  };\n} else {\n  window['Smart'].RenderMode = 'manual';\n}\nimport '../source/modules/smart.scheduler';\nimport * as pkg from '../common/rrule.min.js';\nwindow.rrule = {\n  RRule: pkg.default\n};\nimport React from 'react';\nvar Smart = window.Smart;\n/**\r\n Scheduler displays a set ot Events in Day, Week, Month, Agenda, Timeline Day, Timeline Week, Timeline Month views.\r\n*/\nvar Scheduler = /*#__PURE__*/function (_React$Component) {\n  _inherits(Scheduler, _React$Component);\n  function Scheduler(props) {\n    var _this;\n    _classCallCheck(this, Scheduler);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Scheduler).call(this, props));\n    _this.componentRef = React.createRef();\n    return _this;\n  }\n  // Gets the id of the React component.\n  _createClass(Scheduler, [{\n    key: \"addEvent\",\n    /** Adds an event to the Scheduler. Accepts an event object of the following format (same as the dataSource format): { label?: string, dateStart: date, dateEnd: date, description?: string, id?: string | number, class?: string, backgroundColor?: string, color?: string, notifications?: { interval: numeric, type?: string, time: number[] }[], allDay?: boolean, disableDrag?: boolean, disableResize?: boolean, repeat?: { repeatFreq: string, repeatInterval: number, repeatOn?: number | number[] | date, repeatEnd?: number | date, exceptions?: { date: date, dateStart?: date, dateEnd?: date, hidden?: boolean, backgroundColor?: string, status?: string, label?: string, description?: string, notifications?: { interval: numeric, type?: string, time: number[] }[], disableDrag?: boolean, disableResize?: boolean }[] }, status?: string }\r\n    * @param {any} eventObj. An object describing a Scheduler event that is not already present in the element.\r\n    */\n    value: function addEvent(eventObj) {\n      var _this2 = this;\n      if (this.nativeElement.isRendered) {\n        this.nativeElement.addEvent(eventObj);\n      } else {\n        this.nativeElement.whenRendered(function () {\n          _this2.nativeElement.addEvent(eventObj);\n        });\n      }\n    }\n    /** Adds a new view. Example: scheduler.addView('week', 'My View', 'myView', false, false, 10); scheduler.setView('myView');\r\n    * @param {string} type. The view type.\r\n    * @param {string} label. The view's label displayed in the header.\r\n    * @param {string} value. The view's value used to identify the view.\r\n    * @param {boolean} hideWeekend. Determines whether to hide the weekend.\r\n    * @param {boolean} hideNonworkingWeekdays. Determines whether to hide the non working days.\r\n    * @param {number} additionalDays. Determines whether to add additional days to the view.\r\n    */\n  }, {\n    key: \"addView\",\n    value: function addView(type, label, value, hideWeekend, hideNonworkingWeekdays, additionalDays) {\n      var _this3 = this;\n      if (this.nativeElement.isRendered) {\n        this.nativeElement.addView(type, label, value, hideWeekend, hideNonworkingWeekdays, additionalDays);\n      } else {\n        this.nativeElement.whenRendered(function () {\n          _this3.nativeElement.addView(type, label, value, hideWeekend, hideNonworkingWeekdays, additionalDays);\n        });\n      }\n    }\n    /** Starts an update operation. This is appropriate when calling multiple methods or set multiple properties at once.\r\n    */\n  }, {\n    key: \"beginUpdate\",\n    value: function beginUpdate() {\n      var _this4 = this;\n      if (this.nativeElement.isRendered) {\n        this.nativeElement.beginUpdate();\n      } else {\n        this.nativeElement.whenRendered(function () {\n          _this4.nativeElement.beginUpdate();\n        });\n      }\n    }\n    /** Creates an event and adds it to the Scheduler.\r\n    * @param {string} label. Event label.\r\n    * @param {string} value. Event value.\r\n    * @param {string} dateStart. Event date start.\r\n    * @param {string} dateEnd. Event date end.\r\n    * @param {boolean} allDay. Event all day. Set it to true to create all day event.\r\n    */\n  }, {\n    key: \"createEvent\",\n    value: function createEvent(label, value, dateStart, dateEnd, allDay) {\n      var _this5 = this;\n      if (this.nativeElement.isRendered) {\n        this.nativeElement.createEvent(label, value, dateStart, dateEnd, allDay);\n      } else {\n        this.nativeElement.whenRendered(function () {\n          _this5.nativeElement.createEvent(label, value, dateStart, dateEnd, allDay);\n        });\n      }\n    }\n    /** Ends the update operation. This method will resume the rendering and will refresh the element.\r\n    */\n  }, {\n    key: \"endUpdate\",\n    value: function endUpdate() {\n      var _this6 = this;\n      if (this.nativeElement.isRendered) {\n        this.nativeElement.endUpdate();\n      } else {\n        this.nativeElement.whenRendered(function () {\n          _this6.nativeElement.endUpdate();\n        });\n      }\n    }\n    /** Returns an array of the start and end view dates.\r\n    * @returns {Date[]}\r\n    */\n  }, {\n    key: \"getViewDates\",\n    value: function getViewDates() {\n      var result = this.nativeElement.getViewDates();\n      return result;\n    }\n    /** Refereshes the Scheduler by recalculating the Scrollbars.\r\n    * @param {boolean} fullRefresh?. If set the Scheduler will be re-rendered completely.\r\n    */\n  }, {\n    key: \"refresh\",\n    value: function refresh(fullRefresh) {\n      var _this7 = this;\n      if (this.nativeElement.isRendered) {\n        this.nativeElement.refresh(fullRefresh);\n      } else {\n        this.nativeElement.whenRendered(function () {\n          _this7.nativeElement.refresh(fullRefresh);\n        });\n      }\n    }\n    /** Exports the events from the Scheduler.\r\n    * @param {string} dataFormat. Determines the format of the exported file. The following values are available: <ul><li><b>pdf</b></li><li><b>xlsx</b></li><li><b>html</b></li><li><b>iCal</b></li></ul>\r\n    * @param {any} callback?. A callback that allows to format the exported data based on a condition. For additional details, refer ro the Smart Export Documentation.\r\n    */\n  }, {\n    key: \"exportData\",\n    value: function exportData(dataFormat, callback) {\n      var _this8 = this;\n      if (this.nativeElement.isRendered) {\n        this.nativeElement.exportData(dataFormat, callback);\n      } else {\n        this.nativeElement.whenRendered(function () {\n          _this8.nativeElement.exportData(dataFormat, callback);\n        });\n      }\n    }\n    /** Returns a JSON representation of the events inside the Scheduler.\r\n    * @returns {any}\r\n    */\n  }, {\n    key: \"getDataSource\",\n    value: function getDataSource() {\n      var result = this.nativeElement.getDataSource();\n      return result;\n    }\n    /** Returns a JSON representation of the resources inside the Scheduler.\r\n    * @returns {any}\r\n    */\n  }, {\n    key: \"getResources\",\n    value: function getResources() {\n      var result = this.nativeElement.getResources();\n      return result;\n    }\n    /** Gets a date from coordinates\r\n    * @param {number} x. X coordinate.\r\n    * @param {number} y. Y coordinate.\r\n    * @returns {string}\r\n    */\n  }, {\n    key: \"getDateFromCoordinates\",\n    value: function getDateFromCoordinates(x, y) {\n      var result = this.nativeElement.getDateFromCoordinates(x, y);\n      return result;\n    }\n    /** Gets whether a cell is all day cell from coordinates\r\n    * @param {number} x. X coordinate.\r\n    * @param {number} y. Y coordinate.\r\n    * @returns {boolean}\r\n    */\n  }, {\n    key: \"getIsAllDayCellFromCoordinates\",\n    value: function getIsAllDayCellFromCoordinates(x, y) {\n      var result = this.nativeElement.getIsAllDayCellFromCoordinates(x, y);\n      return result;\n    }\n    /** Returns the current state of the Scheduler. Includes the current dateCurernt, dataSource and timeZone properties.\r\n    * @returns {any}\r\n    */\n  }, {\n    key: \"getState\",\n    value: function getState() {\n      var result = this.nativeElement.getState();\n      return result;\n    }\n    /** Removes a previously saved state of the element form LocalStorage according to it's id. Requires an id to be set to the element.\r\n    */\n  }, {\n    key: \"clearState\",\n    value: function clearState() {\n      var _this9 = this;\n      if (this.nativeElement.isRendered) {\n        this.nativeElement.clearState();\n      } else {\n        this.nativeElement.whenRendered(function () {\n          _this9.nativeElement.clearState();\n        });\n      }\n    }\n    /** Loads a previously saved state of the element or checks LocalStorage for any saved states if no argument is passed to the method.\r\n    * @param {any[]} state?. An Array containing a valid structure of Scheduler events. If no state is provided, the element will check localStorage for a saved state.\r\n    */\n  }, {\n    key: \"loadState\",\n    value: function loadState(state) {\n      var _this10 = this;\n      if (this.nativeElement.isRendered) {\n        this.nativeElement.loadState(state);\n      } else {\n        this.nativeElement.whenRendered(function () {\n          _this10.nativeElement.loadState(state);\n        });\n      }\n    }\n    /** Saves the current events of the element to LocalStorage. Requires an id to be set to the element.\r\n    * @param {any[]} state?. An Array containing a valid structure of Scheduler events.\r\n    */\n  }, {\n    key: \"saveState\",\n    value: function saveState(state) {\n      var _this11 = this;\n      if (this.nativeElement.isRendered) {\n        this.nativeElement.saveState(state);\n      } else {\n        this.nativeElement.whenRendered(function () {\n          _this11.nativeElement.saveState(state);\n        });\n      }\n    }\n    /** Sets the Scheduler's view. Example: scheduler.addView('week', 'My View', 'myView', false, false, 10); scheduler.setView('myView');\r\n    * @param {string} view?. The view's value. For example: 'day'.\r\n    */\n  }, {\n    key: \"setView\",\n    value: function setView(view) {\n      var _this12 = this;\n      if (this.nativeElement.isRendered) {\n        this.nativeElement.setView(view);\n      } else {\n        this.nativeElement.whenRendered(function () {\n          _this12.nativeElement.setView(view);\n        });\n      }\n    }\n    /** Checks whether the Scheduler contains the event.\r\n    * @param {any} eventObj. A Scheduler event object.\r\n    * @returns {boolean}\r\n    */\n  }, {\n    key: \"containsEvent\",\n    value: function containsEvent(eventObj) {\n      var result = this.nativeElement.containsEvent(eventObj);\n      return result;\n    }\n    /** Inserts an event as object of the following format (same as the dataSource format): { label?: string, dateStart: date, dateEnd: date, description?: string, id?: string | number, class?: string, backgroundColor?: string, color?: string, notifications?: { interval: numeric, type?: string, time: number[] }[], allDay?: boolean, disableDrag?: boolean, disableResize?: boolean, repeat?: { repeatFreq: string, repeatInterval: number, repeatOn?: number | number[] | date, repeatEnd?: number | date, exceptions?: { date: date, dateStart?: date, dateEnd?: date, hidden?: boolean, backgroundColor?: string, status?: string, label?: string, description?: string, notifications?: { interval: numeric, type?: string, time: number[] }[], disableDrag?: boolean, disableResize?: boolean }[] }, status?: string }\r\n    * @param {any} eventObj. An object describing a Scheduler event that is not already present in the element.\r\n    * @param {number} index?. A number that represents the index to insert the event at. If not provided the event is inserted at the end of the list.\r\n    */\n  }, {\n    key: \"insertEvent\",\n    value: function insertEvent(eventObj, index) {\n      var _this13 = this;\n      if (this.nativeElement.isRendered) {\n        this.nativeElement.insertEvent(eventObj, index);\n      } else {\n        this.nativeElement.whenRendered(function () {\n          _this13.nativeElement.insertEvent(eventObj, index);\n        });\n      }\n    }\n    /** Updates an event object of the following format (same as the dataSource format): { label?: string, dateStart: date, dateEnd: date, description?: string, id?: string | number, class?: string, backgroundColor?: string, color?: string, notifications?: { interval: numeric, type?: string, time: number[] }[], allDay?: boolean, disableDrag?: boolean, disableResize?: boolean, repeat?: { repeatFreq: string, repeatInterval: number, repeatOn?: number | number[] | date, repeatEnd?: number | date, exceptions?: { date: date, dateStart?: date, dateEnd?: date, hidden?: boolean, backgroundColor?: string, status?: string, label?: string, description?: string, notifications?: { interval: numeric, type?: string, time: number[] }[], disableDrag?: boolean, disableResize?: boolean }[] }, status?: string }\r\n    * @param {any} index. A number that represents the index of an event or a Scheduler event object.\r\n    * @param {any} eventObj. An object describing a Scheduler event. The properties of this object will be applied to the desired event.\r\n    */\n  }, {\n    key: \"updateEvent\",\n    value: function updateEvent(index, eventObj) {\n      var _this14 = this;\n      if (this.nativeElement.isRendered) {\n        this.nativeElement.updateEvent(index, eventObj);\n      } else {\n        this.nativeElement.whenRendered(function () {\n          _this14.nativeElement.updateEvent(index, eventObj);\n        });\n      }\n    }\n    /** Removes an existing event.\r\n    * @param {any} index. A number that represents the index of an event or the actual event object to be removed.\r\n    */\n  }, {\n    key: \"removeEvent\",\n    value: function removeEvent(index) {\n      var _this15 = this;\n      if (this.nativeElement.isRendered) {\n        this.nativeElement.removeEvent(index);\n      } else {\n        this.nativeElement.whenRendered(function () {\n          _this15.nativeElement.removeEvent(index);\n        });\n      }\n    }\n    /** Returns an array of all exceptions of the target repeating event.\r\n    * @param {any} eventObj. The index, id or an object reference of an existing repeating Scheduler event.\r\n    * @returns {any}\r\n    */\n  }, {\n    key: \"getEventExceptions\",\n    value: function getEventExceptions(eventObj) {\n      var result = this.nativeElement.getEventExceptions(eventObj);\n      return result;\n    }\n    /** Adds an event exception to a repeating event. The exception occurences for a repeating event can be gathered via the following methods: occurencesoccurrencesBetweenoccurrenceAfteroccurrenceBefore.  Example usage: scheduler.addEventException(eventObj, { date: occuranceDate, dateStart: newDateStart, dateEnd: newDateEnd, label: 'Exception' });\r\n    * @param {any} eventObj. The index, id or an object reference of an existing repeating Scheduler event.\r\n    * @param {any} exceptionObj. An event object that describes an exception. Exception event objects must have a <b>date</b> attribute of type Date which indicates the date of occurence.\r\n    */\n  }, {\n    key: \"addEventException\",\n    value: function addEventException(eventObj, exceptionObj) {\n      var _this16 = this;\n      if (this.nativeElement.isRendered) {\n        this.nativeElement.addEventException(eventObj, exceptionObj);\n      } else {\n        this.nativeElement.whenRendered(function () {\n          _this16.nativeElement.addEventException(eventObj, exceptionObj);\n        });\n      }\n    }\n    /** Updates an event exception of a repeating event. The exception occurences for a repeating event can be gathered via the following methods: occurencesoccurrencesBetweenoccurrenceAfteroccurrenceBefore.  Example usage: scheduler.updateEventException(eventObj, dateOfOccurance, { dateStart: newDateStart, dateEnd: newDateEnd, label: 'Updated Exception' });\r\n    * @param {any} eventObj. The index, id or an object reference of an existing repeating Scheduler event.\r\n    * @param {any} exceptionRef. The index, id, an occurence date of the exception or an object reference of an existing Scheduler repeating event exception.\r\n    * @param {any} exceptionObj. An event object that describes an exception. All attributes of an exception can be updated except the occurance date (the <b>date</b> attribute).\r\n    */\n  }, {\n    key: \"updateEventException\",\n    value: function updateEventException(eventObj, exceptionRef, exceptionObj) {\n      var _this17 = this;\n      if (this.nativeElement.isRendered) {\n        this.nativeElement.updateEventException(eventObj, exceptionRef, exceptionObj);\n      } else {\n        this.nativeElement.whenRendered(function () {\n          _this17.nativeElement.updateEventException(eventObj, exceptionRef, exceptionObj);\n        });\n      }\n    }\n    /** Removes an exception from a repeating event.\r\n    * @param {any} eventObj. The index, id or an object reference of an existing repeating Scheduler event.\r\n    * @param {any} index. The index, id, occurance date or an object reference of an event exception that belongs to the target repeating event.\r\n    */\n  }, {\n    key: \"removeEventException\",\n    value: function removeEventException(eventObj, index) {\n      var _this18 = this;\n      if (this.nativeElement.isRendered) {\n        this.nativeElement.removeEventException(eventObj, index);\n      } else {\n        this.nativeElement.whenRendered(function () {\n          _this18.nativeElement.removeEventException(eventObj, index);\n        });\n      }\n    }\n    /** Opens the popup Window for specific event Editing.\r\n    * @param {any} index. A number that represents the index of a event or the actual event object to be edited.\r\n    */\n  }, {\n    key: \"openWindow\",\n    value: function openWindow(index) {\n      var _this19 = this;\n      if (this.nativeElement.isRendered) {\n        this.nativeElement.openWindow(index);\n      } else {\n        this.nativeElement.whenRendered(function () {\n          _this19.nativeElement.openWindow(index);\n        });\n      }\n    }\n    /** Closes the popup window.\r\n    */\n  }, {\n    key: \"closeWindow\",\n    value: function closeWindow() {\n      var _this20 = this;\n      if (this.nativeElement.isRendered) {\n        this.nativeElement.closeWindow();\n      } else {\n        this.nativeElement.whenRendered(function () {\n          _this20.nativeElement.closeWindow();\n        });\n      }\n    }\n    /** Prepares the Scheduler for printing by opening the browser's Print Preview.\r\n    */\n  }, {\n    key: \"print\",\n    value: function print() {\n      var _this21 = this;\n      if (this.nativeElement.isRendered) {\n        this.nativeElement.print();\n      } else {\n        this.nativeElement.whenRendered(function () {\n          _this21.nativeElement.print();\n        });\n      }\n    }\n    /** Scrolls the Scheduler to a Date.\r\n    * @param {Date} date. The date to scroll to.\r\n    * @param {boolean} strictScroll?. Determines whether to scroll strictly to the date or not. This mean sthat the Scheduler wll scroll to the begining of the cell that corresponds to the target date.\r\n    * @param {boolean} autoScroll?. Calculates the scroll positions and element bounds, then adds an offset to scroll within the middle of the view.\r\n    */\n  }, {\n    key: \"scrollToDate\",\n    value: function scrollToDate(date, strictScroll, autoScroll) {\n      var _this22 = this;\n      if (this.nativeElement.isRendered) {\n        this.nativeElement.scrollToDate(date, strictScroll, autoScroll);\n      } else {\n        this.nativeElement.whenRendered(function () {\n          _this22.nativeElement.scrollToDate(date, strictScroll, autoScroll);\n        });\n      }\n    }\n    /** Navigates the Scheduler to a Date.\r\n    * @param {Date} date. The date to navigate to.\r\n    */\n  }, {\n    key: \"navigateToDate\",\n    value: function navigateToDate(date) {\n      var _this23 = this;\n      if (this.nativeElement.isRendered) {\n        this.nativeElement.navigateToDate(date);\n      } else {\n        this.nativeElement.whenRendered(function () {\n          _this23.nativeElement.navigateToDate(date);\n        });\n      }\n    }\n    /** Scrolls the Scheduler to an event.\r\n    * @param {any} index. The index of a Scheduler event or the actual event object to scroll to.\r\n    */\n  }, {\n    key: \"scrollToEvent\",\n    value: function scrollToEvent(index) {\n      var _this24 = this;\n      if (this.nativeElement.isRendered) {\n        this.nativeElement.scrollToEvent(index);\n      } else {\n        this.nativeElement.whenRendered(function () {\n          _this24.nativeElement.scrollToEvent(index);\n        });\n      }\n    }\n    /** Opens a custom notification.\r\n    * @param {string} message. The notification message.\r\n    * @param {any} toastSettings. Smart.Toast settings to be applied to the Toast element when opening the notification.\r\n    */\n  }, {\n    key: \"openNotification\",\n    value: function openNotification(message, toastSettings) {\n      var _this25 = this;\n      if (this.nativeElement.isRendered) {\n        this.nativeElement.openNotification(message, toastSettings);\n      } else {\n        this.nativeElement.whenRendered(function () {\n          _this25.nativeElement.openNotification(message, toastSettings);\n        });\n      }\n    }\n    /** Closes all notifications.\r\n    */\n  }, {\n    key: \"closeNotifications\",\n    value: function closeNotifications() {\n      var _this26 = this;\n      if (this.nativeElement.isRendered) {\n        this.nativeElement.closeNotifications();\n      } else {\n        this.nativeElement.whenRendered(function () {\n          _this26.nativeElement.closeNotifications();\n        });\n      }\n    }\n    /** Returns all occurances of an event.\r\n    * @param {any} eventObj. A Scheduler evnet object.\r\n    * @param {number} count. The number of occurances to return. By default 100 date occurances of the event are returned.\r\n    */\n  }, {\n    key: \"occurrences\",\n    value: function occurrences(eventObj, count) {\n      var _this27 = this;\n      if (this.nativeElement.isRendered) {\n        this.nativeElement.occurrences(eventObj, count);\n      } else {\n        this.nativeElement.whenRendered(function () {\n          _this27.nativeElement.occurrences(eventObj, count);\n        });\n      }\n    }\n    /** Returns all occurances of an event between two dates.\r\n    * @param {any} eventObj. A Scheduler event object.\r\n    * @param {Date} dateFrom. The start date.\r\n    * @param {Date} dateTo. The end date.\r\n    */\n  }, {\n    key: \"occurrencesBetween\",\n    value: function occurrencesBetween(eventObj, dateFrom, dateTo) {\n      var _this28 = this;\n      if (this.nativeElement.isRendered) {\n        this.nativeElement.occurrencesBetween(eventObj, dateFrom, dateTo);\n      } else {\n        this.nativeElement.whenRendered(function () {\n          _this28.nativeElement.occurrencesBetween(eventObj, dateFrom, dateTo);\n        });\n      }\n    }\n    /** Returns the first occurance of an event after a date.\r\n    * @param {any} eventObj. A Scheduler event object.\r\n    * @param {number} date. The date after which the first occurance of the event will be returned.\r\n    */\n  }, {\n    key: \"occurrenceAfter\",\n    value: function occurrenceAfter(eventObj, date) {\n      var _this29 = this;\n      if (this.nativeElement.isRendered) {\n        this.nativeElement.occurrenceAfter(eventObj, date);\n      } else {\n        this.nativeElement.whenRendered(function () {\n          _this29.nativeElement.occurrenceAfter(eventObj, date);\n        });\n      }\n    }\n    /** Returns the last occurance of an event before a date.\r\n    * @param {any} eventObj. A Scheduler event object.\r\n    * @param {number} date. The date before which the first occurance of the event will be returned.\r\n    */\n  }, {\n    key: \"occurrenceBefore\",\n    value: function occurrenceBefore(eventObj, date) {\n      var _this30 = this;\n      if (this.nativeElement.isRendered) {\n        this.nativeElement.occurrenceBefore(eventObj, date);\n      } else {\n        this.nativeElement.whenRendered(function () {\n          _this30.nativeElement.occurrenceBefore(eventObj, date);\n        });\n      }\n    }\n    /** Returns the dateStart/dateEnd of a timeline cell.\r\n    * @param {HTMLElement} cell. A Scheduler timeline cell element.\r\n    * @returns {any}\r\n    */\n  }, {\n    key: \"getCellDateRange\",\n    value: function getCellDateRange(cell) {\n      var result = this.nativeElement.getCellDateRange(cell);\n      return result;\n    }\n    /** Opens the tooltip(event menu) for an event.\r\n    * @param {any} eventObj. A Scheduler event object or it's index.\r\n    */\n  }, {\n    key: \"openEventTooltip\",\n    value: function openEventTooltip(eventObj) {\n      var _this31 = this;\n      if (this.nativeElement.isRendered) {\n        this.nativeElement.openEventTooltip(eventObj);\n      } else {\n        this.nativeElement.whenRendered(function () {\n          _this31.nativeElement.openEventTooltip(eventObj);\n        });\n      }\n    }\n    /** Closes the event tooltip (event menu).\r\n    */\n  }, {\n    key: \"closeEventTooltip\",\n    value: function closeEventTooltip() {\n      var _this32 = this;\n      if (this.nativeElement.isRendered) {\n        this.nativeElement.closeEventTooltip();\n      } else {\n        this.nativeElement.whenRendered(function () {\n          _this32.nativeElement.closeEventTooltip();\n        });\n      }\n    }\n    /** Returns true or false whether the date is restricted or not.\r\n    * @param {Date} date. A Date object.\r\n    * @returns {boolean}\r\n    */\n  }, {\n    key: \"isDateRestricted\",\n    value: function isDateRestricted(date) {\n      var result = this.nativeElement.isDateRestricted(date);\n      return result;\n    }\n    /** Returns true or false whether the hour is restricted or not.\r\n    * @param {number | Date} hour. A number that represents an hour ( 0 to 23 ) or a Date object.\r\n    * @returns {boolean}\r\n    */\n  }, {\n    key: \"isHourRestricted\",\n    value: function isHourRestricted(hour) {\n      var result = this.nativeElement.isHourRestricted(hour);\n      return result;\n    }\n    /** Returns true or false whether the event is restricted or not.\r\n    * @param {any} eventObj. A Scheduler event  object or a direct event HTMLElement instance.\r\n    * @returns {boolean}\r\n    */\n  }, {\n    key: \"isEventRestricted\",\n    value: function isEventRestricted(eventObj) {\n      var result = this.nativeElement.isEventRestricted(eventObj);\n      return result;\n    }\n    /** Deletes the current undo/redo history.\r\n    * @returns {boolean}\r\n    */\n  }, {\n    key: \"deleteUndoRedoHistory\",\n    value: function deleteUndoRedoHistory() {\n      var result = this.nativeElement.deleteUndoRedoHistory();\n      return result;\n    }\n    /** Indicates whether it is possible to redo an action.\r\n    * @returns {boolean}\r\n    */\n  }, {\n    key: \"canRedo\",\n    value: function canRedo() {\n      var result = this.nativeElement.canRedo();\n      return result;\n    }\n    /** Indicates whether it is possbile to undo an action.\r\n    * @returns {boolean}\r\n    */\n  }, {\n    key: \"canUndo\",\n    value: function canUndo() {\n      var result = this.nativeElement.canUndo();\n      return result;\n    }\n    /** Redo the next event modification.\r\n    * @param {number} step?. A step to redo to.\r\n    * @returns {boolean}\r\n    */\n  }, {\n    key: \"redo\",\n    value: function redo(step) {\n      var result = this.nativeElement.redo(step);\n      return result;\n    }\n    /** Undo the last event modification.\r\n    * @param {number} step?. A step to undo to.\r\n    * @returns {boolean}\r\n    */\n  }, {\n    key: \"undo\",\n    value: function undo(step) {\n      var result = this.nativeElement.undo(step);\n      return result;\n    }\n  }, {\n    key: \"componentDidRender\",\n    value: function componentDidRender(initialize) {\n      var that = this;\n      var props = {};\n      var events = {};\n      var styles = null;\n      var stringifyCircularJSON = function stringifyCircularJSON(obj) {\n        var seen = new WeakSet();\n        return JSON.stringify(obj, function (k, v) {\n          if (v !== null && typeof v === 'object') {\n            if (seen.has(v)) return;\n            seen.add(v);\n          }\n          if (k === 'Smart') {\n            return v;\n          }\n          return v;\n        });\n      };\n      for (var prop in that.props) {\n        if (prop === 'children') {\n          continue;\n        }\n        if (prop === 'style') {\n          styles = that.props[prop];\n          continue;\n        }\n        if (prop.startsWith('on') && that.properties.indexOf(prop) === -1) {\n          events[prop] = that.props[prop];\n          continue;\n        }\n        props[prop] = that.props[prop];\n      }\n      if (initialize) {\n        that.nativeElement = this.componentRef.current;\n        if (that.nativeElement && !that.nativeElement.isCompleted) {\n          that.nativeElement.reactStateProps = JSON.parse(stringifyCircularJSON(props));\n        }\n      }\n      if (initialize && that.nativeElement && that.nativeElement.isCompleted) {\n        //\treturn;\n      }\n      for (var _prop in props) {\n        if (_prop === 'class' || _prop === 'className') {\n          var classNames = props[_prop].trim().split(' ');\n          for (var className in classNames) {\n            if (!that.nativeElement.classList.contains(classNames[className]) && classNames[className] !== \"\") {\n              that.nativeElement.classList.add(classNames[className]);\n            }\n          }\n          continue;\n        }\n        if (props[_prop] !== that.nativeElement[_prop]) {\n          var normalizeProp = function normalizeProp(str) {\n            return str.replace(/-([a-z])/g, function (g) {\n              return g[1].toUpperCase();\n            });\n          };\n          if (_prop === 'hover' || _prop === 'active' || _prop === 'focus' || _prop === 'selected') {\n            that.nativeElement.setAttribute(_prop, '');\n          }\n          var normalizedProp = normalizeProp(_prop);\n          if (that.nativeElement[normalizedProp] === undefined) {\n            that.nativeElement.setAttribute(_prop, props[_prop]);\n          }\n          if (props[_prop] !== undefined) {\n            if (typeof props[_prop] === 'object' && that.nativeElement.reactStateProps && !initialize) {\n              if (stringifyCircularJSON(props[_prop]) === stringifyCircularJSON(that.nativeElement.reactStateProps[normalizedProp])) {\n                continue;\n              }\n            }\n            that.nativeElement[normalizedProp] = props[_prop];\n          }\n        }\n      }\n      for (var eventName in events) {\n        that[eventName] = events[eventName];\n        that.nativeElement[eventName.toLowerCase()] = events[eventName];\n      }\n      if (initialize) {\n        Smart.Render();\n        if (that.onCreate) {\n          that.onCreate();\n        }\n        that.nativeElement.whenRendered(function () {\n          if (that.onReady) {\n            that.onReady();\n          }\n        });\n      }\n      // setup styles.\n      if (styles) {\n        for (var styleName in styles) {\n          that.nativeElement.style[styleName] = styles[styleName];\n        }\n      }\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.componentDidRender(true);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      this.componentDidRender(false);\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      var that = this;\n      if (!that.nativeElement) {\n        return;\n      }\n      that.nativeElement.whenRenderedCallbacks = [];\n      for (var i = 0; i < that.eventListeners.length; i++) {\n        var eventName = that.eventListeners[i];\n        that.nativeElement.removeEventListener(eventName.substring(2).toLowerCase(), that[eventName]);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return React.createElement(\"smart-scheduler\", {\n        ref: this.componentRef\n      }, this.props.children);\n    }\n  }, {\n    key: \"id\",\n    get: function get() {\n      if (!this._id) {\n        this._id = 'Scheduler' + Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n      }\n      return this._id;\n    }\n    /** Determines the scroll speed while dragging an event.\r\n    *\tProperty type: number\r\n    */\n  }, {\n    key: \"autoScrollStep\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.autoScrollStep : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.autoScrollStep = value;\n      }\n    }\n    /** Determines whether the all day cells in Day and Week views automatically change their height depending on the events count in these cells.\r\n    *\tProperty type: boolean\r\n    */\n  }, {\n    key: \"autoHeightAllDayCells\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.autoHeightAllDayCells : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.autoHeightAllDayCells = value;\n      }\n    }\n    /** Defines an array of objects with start and end fields, where start and end are Date objects. For example: [{  'start': '2022-10-25T12:00.000Z', 'end': '2022-10-25T13:00.000Z' }].\r\n    *\tProperty type: any\r\n    */\n  }, {\n    key: \"available\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.available : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.available = value;\n      }\n    }\n    /** Determines the color scheme for the event background selector in the event window editor.\r\n    *\tProperty type: string[]\r\n    */\n  }, {\n    key: \"colorScheme\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.colorScheme : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.colorScheme = value;\n      }\n    }\n    /** Determines the current time of the Scheduler to use for the current time indicator functionality. By default the current time is Today.\r\n    *\tProperty type: string | Date\r\n    */\n  }, {\n    key: \"currentTime\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.currentTime : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.currentTime = value;\n      }\n    }\n    /** Enables/Disables the current time indicator. Current time indicator shows the current time in the appropriate view cells.\r\n    *\tProperty type: boolean\r\n    */\n  }, {\n    key: \"currentTimeIndicator\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.currentTimeIndicator : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.currentTimeIndicator = value;\n      }\n    }\n    /** Determines the refresh interval in seconds for the currentTimeIndicator.\r\n    *\tProperty type: number\r\n    */\n  }, {\n    key: \"currentTimeIndicatorInterval\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.currentTimeIndicatorInterval : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.currentTimeIndicatorInterval = value;\n      }\n    }\n    /** Determines the context menu items that are visible when the Context Menu is opened.\r\n    *\tProperty type: any[]\r\n    */\n  }, {\n    key: \"contextMenuDataSource\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.contextMenuDataSource : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.contextMenuDataSource = value;\n      }\n    }\n    /** Determines whether the clipboard shortcuts for copy/paste/cut action of events are visible in the Scheduler context menu or not.\r\n    *\tProperty type: boolean\r\n    */\n  }, {\n    key: \"contextMenuClipboardActions\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.contextMenuClipboardActions : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.contextMenuClipboardActions = value;\n      }\n    }\n    /** Allows to customize the content of the event elements. It can be an HTMLTemplateElement that will be applied to all events or it's id as a string or a function that will be called for each event with the following parameters: eventContent - the content holder for the event,eventObj - the event object.. When using an HTMLTemplateElement it's possible to add property bindings inside the template that will be mapped to the corresponding object properties.\r\n    *\tProperty type: any\r\n    */\n  }, {\n    key: \"eventTemplate\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.eventTemplate : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.eventTemplate = value;\n      }\n    }\n    /** Allows to customize the content of the event collector elements. It can be an HTMLTemplateElement that will be applied to all events or it's id as a string or a function that will be called for each event with the following parameters: eventContent - the content holder for the event,eventObj - the event object.. When using an HTMLTemplateElement it's possible to add property bindings inside the template that will be mapped to the corresponding object properties.\r\n    *\tProperty type: any\r\n    */\n  }, {\n    key: \"eventCollectorTemplate\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.eventCollectorTemplate : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.eventCollectorTemplate = value;\n      }\n    }\n    /**  Determines how the events inside the Scheduler are rendered.classic - the events are arranged next to each other and try to fit inside the cells.modern - the events obey the CSS property that determines their size and if there's not enough space inside the cell for all events to appear, an event collector is created to hold the rest of the events. On mobile phones only collectors are created.\r\n    *\tProperty type: SchedulerEventRenderMode | string\r\n    */\n  }, {\n    key: \"eventRenderMode\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.eventRenderMode : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.eventRenderMode = value;\n      }\n    }\n    /** Allows to customize the content of the event menu items (tooltip). When clicked on an event element an event menu with details opens. It can be an HTMLTemplateElement that will be applied to all events or it's id as a string or a function that will be called for each event with the following parameters: eventContent - the content holder for the event,eventObj - the event object.. When using an HTMLTemplateElement it's possible to add property bindings inside the template that will be mapped to the corresponding object properties.\r\n    *\tProperty type: any\r\n    */\n  }, {\n    key: \"eventTooltipTemplate\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.eventTooltipTemplate : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.eventTooltipTemplate = value;\n      }\n    }\n    /** Allows to customize the content of the timeline cells. It can be an HTMLTemplateElement that will be applied to all cells or it's id as a string or a function that will be called for each cell with the following parameters: cellContent - the content holder for the cell,cellDate - the cell date.. When using an HTMLTemplateElement it's possible to add property bindings inside the template that will be mapped to the value of the cell.\r\n    *\tProperty type: any\r\n    */\n  }, {\n    key: \"cellTemplate\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.cellTemplate : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.cellTemplate = value;\n      }\n    }\n    /** Determines the currently visible date for the Scheduler.\r\n    *\tProperty type: string | Date\r\n    */\n  }, {\n    key: \"dateCurrent\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.dateCurrent : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.dateCurrent = value;\n      }\n    }\n    /** Sets the Schedulers's Data Export options.\r\n    *\tProperty type: SchedulerDataExport\r\n    */\n  }, {\n    key: \"dataExport\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.dataExport : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.dataExport = value;\n      }\n    }\n    /** Determines the events that will be loaded inside the Timeline. Each event represents an object that should contain the following properties:\r\n    *\tProperty type: SchedulerEvent[]\r\n    */\n  }, {\n    key: \"dataSource\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.dataSource : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.dataSource = value;\n      }\n    }\n    /** A callback that can be used to customize the text inside the date selector located in the header. The callback has one parameter - the current date.\r\n    *\tProperty type: any\r\n    */\n  }, {\n    key: \"dateSelectorFormatFunction\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.dateSelectorFormatFunction : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.dateSelectorFormatFunction = value;\n      }\n    }\n    /** Determines the day format of the dates in the timeline.\r\n    *\tProperty type: SchedulerDayFormat | string\r\n    */\n  }, {\n    key: \"dayFormat\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.dayFormat : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.dayFormat = value;\n      }\n    }\n    /** Enables or disables the element.\r\n    *\tProperty type: boolean\r\n    */\n  }, {\n    key: \"disabled\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.disabled : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.disabled = value;\n      }\n    }\n    /** Disables auto scrolling of the timeline while dragging/resizing an event.\r\n    *\tProperty type: boolean\r\n    */\n  }, {\n    key: \"disableAutoScroll\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.disableAutoScroll : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.disableAutoScroll = value;\n      }\n    }\n    /** Disables dragging of events.\r\n    *\tProperty type: boolean\r\n    */\n  }, {\n    key: \"disableDrag\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.disableDrag : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.disableDrag = value;\n      }\n    }\n    /** Disables dropping of events.\r\n    *\tProperty type: boolean\r\n    */\n  }, {\n    key: \"disableDrop\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.disableDrop : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.disableDrop = value;\n      }\n    }\n    /** Disables resizing of events.\r\n    *\tProperty type: boolean\r\n    */\n  }, {\n    key: \"disableResize\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.disableResize : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.disableResize = value;\n      }\n    }\n    /** Disables the cell selection.\r\n    *\tProperty type: boolean\r\n    */\n  }, {\n    key: \"disableSelection\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.disableSelection : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.disableSelection = value;\n      }\n    }\n    /** Disables the window editor for the events.\r\n    *\tProperty type: boolean\r\n    */\n  }, {\n    key: \"disableWindowEditor\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.disableWindowEditor : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.disableWindowEditor = value;\n      }\n    }\n    /** Disables the context menu of the events and cells.\r\n    *\tProperty type: boolean\r\n    */\n  }, {\n    key: \"disableContextMenu\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.disableContextMenu : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.disableContextMenu = value;\n      }\n    }\n    /** Disables the event menu that appears when an event/collector has been clicked.\r\n    *\tProperty type: boolean\r\n    */\n  }, {\n    key: \"disableEventMenu\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.disableEventMenu : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.disableEventMenu = value;\n      }\n    }\n    /** Disables the view menu that allows to select the current Scheduler view.\r\n    *\tProperty type: boolean\r\n    */\n  }, {\n    key: \"disableViewMenu\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.disableViewMenu : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.disableViewMenu = value;\n      }\n    }\n    /** Disables the date menu that allows to select the current Scheduler date.\r\n    *\tProperty type: boolean\r\n    */\n  }, {\n    key: \"disableDateMenu\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.disableDateMenu : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.disableDateMenu = value;\n      }\n    }\n    /** A callback that can be used to customize the drag feedback that appears when an event is dragged.\r\n    *\tProperty type: any\r\n    */\n  }, {\n    key: \"dragFeedbackFormatFunction\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.dragFeedbackFormatFunction : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.dragFeedbackFormatFunction = value;\n      }\n    }\n    /** Determines the offset for the drag feedback from the pointer.\r\n    *\tProperty type: any\r\n    */\n  }, {\n    key: \"dragOffset\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.dragOffset : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.dragOffset = value;\n      }\n    }\n    /** Determines the filtering condition for the events.The filter property takes an array of objects or a function. Each object represents a single filtering condition with the following attributes: name - the name of the Scheduler event property that will be filtered by.value - the filtering condition value. The value will be used to compare the events based on the filterMode, for example: [{ name: 'price', value: 25 }]. The value can also be a function. The function accepts a single arguemnt - the value that corresponds to the filtered attribute. The function allows to apply custom condition that is different from the default filter modes. It should return true ( if the evnet passes the filtering condition ) or false ( if the event does not meet the filtering condition ). Here's an example: [{ name: 'roomId', value: (id) => ['2', '3'].indexOf(id + '') > -1 }]. In the example the events that do not have a 'roomId' property that is equal to '2' or '3' will be filtered out.. If a function is set to the filter property instead, it allows to completely customize the filtering logic. The function passes a single argument - each Scheduler event that will be displayed. The function should return true ( if the condition is met ) or false ( if not ).\r\n    *\tProperty type: any\r\n    */\n  }, {\n    key: \"filter\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.filter : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.filter = value;\n      }\n    }\n    /** Determines whether Scheduler's filtering is enabled or not.\r\n    *\tProperty type: any\r\n    */\n  }, {\n    key: \"filterable\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.filterable : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.filterable = value;\n      }\n    }\n    /** Determines the filter mode.\r\n    *\tProperty type: FilterMode | string\r\n    */\n  }, {\n    key: \"filterMode\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.filterMode : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.filterMode = value;\n      }\n    }\n    /** A getter that returns  an array of all Scheduler events.\r\n    *\tProperty type: SchedulerEvent[]\r\n    */\n  }, {\n    key: \"events\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.events : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.events = value;\n      }\n    }\n    /** Determines the first day of week for the Scheduler. By default it's Sunday.\r\n    *\tProperty type: number\r\n    */\n  }, {\n    key: \"firstDayOfWeek\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.firstDayOfWeek : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.firstDayOfWeek = value;\n      }\n    }\n    /** Allows to customize the footer of the Scheduler. It can be an HTMLTemplateElement, it's id as a string or a function with the following parameters: footerContainer - the footer container..\r\n    *\tProperty type: any\r\n    */\n  }, {\n    key: \"footerTemplate\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.footerTemplate : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.footerTemplate = value;\n      }\n    }\n    /** Determines whether the events will be grouped by date.\r\n    *\tProperty type: boolean\r\n    */\n  }, {\n    key: \"groupByDate\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.groupByDate : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.groupByDate = value;\n      }\n    }\n    /** Determines the grouping orientation.\r\n    *\tProperty type: SchedulerGroupOrientation | string\r\n    */\n  }, {\n    key: \"groupOrientation\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.groupOrientation : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.groupOrientation = value;\n      }\n    }\n    /** Allows to customize the content of the group cells that are visible inside the header. It can be an HTMLTemplateElement that will be applied to all cells or it's id as a string or a function that will be called for each group cell with the following parameters: cellContent - the content holder for the group cell.cellObj - the group cell object.. When using an HTMLTemplateElement it's possible to add property bindings inside the template that will be mapped to the corresponding object properties.\r\n    *\tProperty type: any\r\n    */\n  }, {\n    key: \"groupTemplate\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.groupTemplate : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.groupTemplate = value;\n      }\n    }\n    /** Determines the resources that the events are grouped by.\r\n    *\tProperty type: any\r\n    */\n  }, {\n    key: \"groups\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.groups : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.groups = value;\n      }\n    }\n    /** Determines the end hour that will be displayed in 'day' and 'week' views.\r\n    *\tProperty type: number\r\n    */\n  }, {\n    key: \"hourEnd\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.hourEnd : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.hourEnd = value;\n      }\n    }\n    /** Determines the start hour that will be displayed in 'day' and 'week' views.\r\n    *\tProperty type: number\r\n    */\n  }, {\n    key: \"hourStart\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.hourStart : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.hourStart = value;\n      }\n    }\n    /** Determines the formatting of hours inside the element.\r\n    *\tProperty type: SchedulerHourFormat | string\r\n    */\n  }, {\n    key: \"hourFormat\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.hourFormat : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.hourFormat = value;\n      }\n    }\n    /** Allows to customize the header of the Scheduler. It can be an HTMLTemplateElement, it's id as a string or a function with the following parameters: headerContent - the header container..\r\n    *\tProperty type: any\r\n    */\n  }, {\n    key: \"headerTemplate\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.headerTemplate : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.headerTemplate = value;\n      }\n    }\n    /**  Determines the position of the Date selector inside the Header of the element.\r\n    *\tProperty type: SchedulerHeaderDatePosition | string\r\n    */\n  }, {\n    key: \"headerDatePosition\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.headerDatePosition : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.headerDatePosition = value;\n      }\n    }\n    /**  Determines the styling of the Header navigation controls.\r\n    *\tProperty type: SchedulerHeaderNavigationStyle | string\r\n    */\n  }, {\n    key: \"headerNavigationStyle\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.headerNavigationStyle : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.headerNavigationStyle = value;\n      }\n    }\n    /**  Determines the position of the view selector control inside the Header of the element.\r\n    *\tProperty type: SchedulerHeaderViewPosition | string\r\n    */\n  }, {\n    key: \"headerViewPosition\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.headerViewPosition : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.headerViewPosition = value;\n      }\n    }\n    /** Determines whether the 'All Day' container with the all day events is hidden or not.\r\n    *\tProperty type: boolean\r\n    */\n  }, {\n    key: \"hideAllDay\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.hideAllDay : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.hideAllDay = value;\n      }\n    }\n    /** Determines whether the days set by 'nonworkingDays' property are hidden or not.\r\n    *\tProperty type: boolean\r\n    */\n  }, {\n    key: \"hideNonworkingWeekdays\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.hideNonworkingWeekdays : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.hideNonworkingWeekdays = value;\n      }\n    }\n    /** Determines whether other month days are visible when view is set to month. When enabled, events that start on other month days are not displayed and the cells that represent such days do not allow the creation of new events on them. Also dragging and droping an event on other month days is not allowed. Reszing is also affected. Events can end on other month days, but cannot start on one.\r\n    *\tProperty type: boolean\r\n    */\n  }, {\n    key: \"hideOtherMonthDays\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.hideOtherMonthDays : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.hideOtherMonthDays = value;\n      }\n    }\n    /** Determines whether the 'Today' button is hidden or not.\r\n    *\tProperty type: boolean\r\n    */\n  }, {\n    key: \"hideTodayButton\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.hideTodayButton : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.hideTodayButton = value;\n      }\n    }\n    /** Determines whether the checkable items in the view selection menu are hidden or not.\r\n    *\tProperty type: boolean\r\n    */\n  }, {\n    key: \"hideViewMenuCheckableItems\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.hideViewMenuCheckableItems : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.hideViewMenuCheckableItems = value;\n      }\n    }\n    /** Determines whether the weekend days are hidden or not.\r\n    *\tProperty type: boolean\r\n    */\n  }, {\n    key: \"hideWeekend\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.hideWeekend : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.hideWeekend = value;\n      }\n    }\n    /** Determines the location of the legend inside the Scheduler. By default the location is inside the footer but it can also reside in the header.\r\n    *\tProperty type: SchedulerLegendLocation | string\r\n    */\n  }, {\n    key: \"legendLocation\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.legendLocation : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.legendLocation = value;\n      }\n    }\n    /** Determines the position of the legend. By default it's positioned to the near side but setting it to 'far' will change that.\r\n    *\tProperty type: SchedulerLegendPosition | string\r\n    */\n  }, {\n    key: \"legendPosition\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.legendPosition : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.legendPosition = value;\n      }\n    }\n    /** Determines the layout of the legend items.\r\n    *\tProperty type: SchedulerLegendLayout | string\r\n    */\n  }, {\n    key: \"legendLayout\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.legendLayout : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.legendLayout = value;\n      }\n    }\n    /** Determines the number of items when the legend switches automatically from horizontal list to menu.\r\n    *\tProperty type: number\r\n    */\n  }, {\n    key: \"legendLayoutMenuBreakpoint\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.legendLayoutMenuBreakpoint : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.legendLayoutMenuBreakpoint = value;\n      }\n    }\n    /** Determines the mouse wheel step. When this property is set to a positive number, the scroll step with mouse wheel or trackpad will depend on the property value.\r\n    *\tProperty type: number\r\n    */\n  }, {\n    key: \"mouseWheelStep\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.mouseWheelStep : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.mouseWheelStep = value;\n      }\n    }\n    /** Determines weather or not horizontal scrollbar is shown.\r\n    *\tProperty type: HorizontalScrollBarVisibility | string\r\n    */\n  }, {\n    key: \"horizontalScrollBarVisibility\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.horizontalScrollBarVisibility : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.horizontalScrollBarVisibility = value;\n      }\n    }\n    /**  Determines the language of the Scheduler.\r\n    *\tProperty type: string\r\n    */\n  }, {\n    key: \"locale\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.locale : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.locale = value;\n      }\n    }\n    /** Detetmines the maximum view date for the Scheduler.\r\n    *\tProperty type: string | Date\r\n    */\n  }, {\n    key: \"max\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.max : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.max = value;\n      }\n    }\n    /** Detetmines the maximum number of events per Scheduler cell. By default this property is null which means that the number of events per cell is automatically determined by the size of the events.\r\n    *\tProperty type: number | null\r\n    */\n  }, {\n    key: \"maxEventsPerCell\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.maxEventsPerCell : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.maxEventsPerCell = value;\n      }\n    }\n    /** Detetmines the minimum view date for the Scheduler.\r\n    *\tProperty type: string | Date\r\n    */\n  }, {\n    key: \"min\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.min : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.min = value;\n      }\n    }\n    /** Sets or gets an object specifying strings used in the element that can be localized. Used in conjunction with the property locale.\r\n    *\tProperty type: any\r\n    */\n  }, {\n    key: \"messages\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.messages : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.messages = value;\n      }\n    }\n    /** Determines the minute formatting inside the Scheduler.\r\n    *\tProperty type: MinuteFormat | string\r\n    */\n  }, {\n    key: \"minuteFormat\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.minuteFormat : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.minuteFormat = value;\n      }\n    }\n    /** Determines the month name formatting inside the Scheduler.\r\n    *\tProperty type: MonthFormat | string\r\n    */\n  }, {\n    key: \"monthFormat\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.monthFormat : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.monthFormat = value;\n      }\n    }\n    /** Determines the nonworking days of the week from 0 to 6, where 0 is the first day of the week and 6 is the last day. Nonworking days will be colored differently inside the Timeline. The color is determined by a CSS variable.\r\n    *\tProperty type: any\r\n    */\n  }, {\n    key: \"nonworkingDays\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.nonworkingDays : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.nonworkingDays = value;\n      }\n    }\n    /** Determines the nonworking hours of the day. Hours are represented as numbers inside an array, however ranges of hours can be defined as an array with starting and ending hour separated by a comma. In the timline the cells that represent nonworking days are colored differently from the rest.\r\n    *\tProperty type: any\r\n    */\n  }, {\n    key: \"nonworkingHours\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.nonworkingHours : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.nonworkingHours = value;\n      }\n    }\n    /** Determines the interval (in seconds) at which the element will check for notifications.\r\n    *\tProperty type: number\r\n    */\n  }, {\n    key: \"notificationInterval\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.notificationInterval : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.notificationInterval = value;\n      }\n    }\n    /** Determines the visibility of the resize handles.\r\n    *\tProperty type: ResizeHandlesVisibility | string\r\n    */\n  }, {\n    key: \"resizeHandlesVisibility\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.resizeHandlesVisibility : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.resizeHandlesVisibility = value;\n      }\n    }\n    /** Determines the rate at which the element will refresh it's content on element resize. By default it's refresh immediately. This property is used for element resize throttling\r\n    *\tProperty type: number\r\n    */\n  }, {\n    key: \"resizeInterval\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.resizeInterval : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.resizeInterval = value;\n      }\n    }\n    /** An array of resources that can be assigned to the events.\r\n    *\tProperty type: SchedulerResource[]\r\n    */\n  }, {\n    key: \"resources\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.resources : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.resources = value;\n      }\n    }\n    /** Defines an array of dates that are not allowed to have events on. Events that overlap restricted Dates or start/end on them will not be displayed.\r\n    *\tProperty type: any\r\n    */\n  }, {\n    key: \"restrictedDates\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.restrictedDates : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.restrictedDates = value;\n      }\n    }\n    /** Defines an array of hours that are not allowed to have events on. Events that overlap restricted Hours or start/end on them will not be displayed.\r\n    *\tProperty type: any\r\n    */\n  }, {\n    key: \"restrictedHours\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.restrictedHours : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.restrictedHours = value;\n      }\n    }\n    /** Defines an array of dates and hours that are not allowed to have events on. Events that overlap restricted Hours or start/end on them will not be displayed. Each array item is an Object and requires 2 fields - date and hours. For example: { date: new Date(2023, 10, 1), hours: [[0, 6], 12, [20, 23]] }. The hours define a range of restricted hours similartly to the restricted hours property, the date defines a date where the restricted hours will be applied.\r\n    *\tProperty type: any\r\n    */\n  }, {\n    key: \"restricted\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.restricted : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.restricted = value;\n      }\n    }\n    /** Sets or gets the value indicating whether the element is aligned to support locales using right-to-left fonts.\r\n    *\tProperty type: boolean\r\n    */\n  }, {\n    key: \"rightToLeft\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.rightToLeft : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.rightToLeft = value;\n      }\n    }\n    /**  Determines the position of the date navigation navigation buttons inside the header of the element.\r\n    *\tProperty type: SchedulerScrollButtonsPosition | string\r\n    */\n  }, {\n    key: \"scrollButtonsPosition\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.scrollButtonsPosition : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.scrollButtonsPosition = value;\n      }\n    }\n    /** Enables/Disables the current time shader. If enabled all cells that represent past time will be shaded.\r\n    *\tProperty type: boolean\r\n    */\n  }, {\n    key: \"shadeUntilCurrentTime\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.shadeUntilCurrentTime : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.shadeUntilCurrentTime = value;\n      }\n    }\n    /** Determines whether the resource legend is visible or not. The Legend shows the resources and their items in the footer section of the Scheduler. If filterable is enabled it is possible to filter by resource items by clicking on the corresponding resource item from the legend.\r\n    *\tProperty type: boolean\r\n    */\n  }, {\n    key: \"showLegend\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.showLegend : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.showLegend = value;\n      }\n    }\n    /** Determines the name of the resource data item property that will be used for sorting the resource data defined as the resource.dataSource.\r\n    *\tProperty type: string\r\n    */\n  }, {\n    key: \"sortBy\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.sortBy : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.sortBy = value;\n      }\n    }\n    /** Allows to define a custom sorting function that will be used to sort the resource data. The sortFunction is used when sortOrder is set to custom.\r\n    *\tProperty type: any\r\n    */\n  }, {\n    key: \"sortFunction\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.sortFunction : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.sortFunction = value;\n      }\n    }\n    /** Determines the sorting order of the resource data items. When set to custom, a custom sorting function has to be defined for the sortFunction property. The asc stands for 'ascending' while desc means 'descending' sorting order.\r\n    *\tProperty type: SchedulerSortOrder | string\r\n    */\n  }, {\n    key: \"sortOrder\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.sortOrder : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.sortOrder = value;\n      }\n    }\n    /** Determines the repeating delay of the repeat buttons inside the header of the element. Such buttons are the Date navigation buttons and the view scroll buttons.\r\n    *\tProperty type: number\r\n    */\n  }, {\n    key: \"spinButtonsDelay\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.spinButtonsDelay : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.spinButtonsDelay = value;\n      }\n    }\n    /** Determines the initial delay of the repeat buttons inside the header of the element. Such buttons are the Date navigation buttons and the view scroll buttons.\r\n    *\tProperty type: number\r\n    */\n  }, {\n    key: \"spinButtonsInitialDelay\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.spinButtonsInitialDelay : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.spinButtonsInitialDelay = value;\n      }\n    }\n    /** Defines the statuses that will be available for selection thourgh the window editor for the events.\r\n    *\tProperty type: SchedulerStatuse[]\r\n    */\n  }, {\n    key: \"statuses\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.statuses : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.statuses = value;\n      }\n    }\n    /** Sets or gets the element's visual theme.\r\n    *\tProperty type: string\r\n    */\n  }, {\n    key: \"theme\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.theme : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.theme = value;\n      }\n    }\n    /** A format function for the Header of the Timeline. Allows to modify the date labels in the header cells.\r\n    *\tProperty type: any\r\n    */\n  }, {\n    key: \"timelineHeaderFormatFunction\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.timelineHeaderFormatFunction : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.timelineHeaderFormatFunction = value;\n      }\n    }\n    /** Determines the date scale for the timeline cells.\r\n    *\tProperty type: SchedulerTimelineDayScale | string\r\n    */\n  }, {\n    key: \"timelineDayScale\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.timelineDayScale : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.timelineDayScale = value;\n      }\n    }\n    /** Enables/Disables the tick marks next to the time cells in the vertical header of the element. Time header appears in 'day' and 'week' views.\r\n    *\tProperty type: boolean\r\n    */\n  }, {\n    key: \"timeRulerTicks\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.timeRulerTicks : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.timeRulerTicks = value;\n      }\n    }\n    /** Determines the timeZone for the element. By default if the local time zone is used if the property is not set.\r\n    *\tProperty type: SchedulerTimeZone | string\r\n    */\n  }, {\n    key: \"timeZone\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.timeZone : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.timeZone = value;\n      }\n    }\n    /** Allows to display additional timeZones at once along with the default that is set via the timeZone property. Accepts an array values that represent the ids of valid time zones. The possbile time zones can be viewed in the timeZone property description. By default the local time zone is displayed.\r\n    *\tProperty type: any\r\n    */\n  }, {\n    key: \"timeZones\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.timeZones : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.timeZones = value;\n      }\n    }\n    /** Determines the delay ( in miliseconds) before the tooltip/menu appears.\r\n    *\tProperty type: number\r\n    */\n  }, {\n    key: \"tooltipDelay\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.tooltipDelay : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.tooltipDelay = value;\n      }\n    }\n    /** Determines the offset ot the tooltip/menu.\r\n    *\tProperty type: number[]\r\n    */\n  }, {\n    key: \"tooltipOffset\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.tooltipOffset : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.tooltipOffset = value;\n      }\n    }\n    /** Determines weather or not vertical scrollbar is shown.\r\n    *\tProperty type: VerticalScrollBarVisibility | string\r\n    */\n  }, {\n    key: \"verticalScrollBarVisibility\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.verticalScrollBarVisibility : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.verticalScrollBarVisibility = value;\n      }\n    }\n    /** Determines the current view. The property accepts view values that are defined in the views property. Custom views should contain a valid value that will be set as the current view.\r\n    *\tProperty type: string\r\n    */\n  }, {\n    key: \"view\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.view : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.view = value;\n      }\n    }\n    /** Indicates the current Scheduler viewType. Custom views must contain a valid type property that corresponds to one of the view types. This property should not be set.\r\n    *\tProperty type: SchedulerViewType | string\r\n    */\n  }, {\n    key: \"viewType\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.viewType : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.viewType = value;\n      }\n    }\n    /** Determines the viewing date range of the timeline. The property should be set to an array of strings or view objects. When you set it to a string, you should use any of the following: 'day', 'week', 'month', 'agenda', 'timelineDay', 'timelineWeek', 'timelineMonth'. Custom views can be defined as objects instead of strings. The view object should contain the following properties: label - the label for the view.value - the value for the view. The value is the unique identifier for the view.type - the type of view. The type should be one of the default allowed values for a view.hideWeekend - an Optional property that allows to hide the weekend only for this specific view.hideNonworkingWeekdays - an Optional property that allows to hide the nonwrking weekdays for this specific view.shortcutKey - an Optional property that allows to set a custom shortcut key for the view.hideHours - an Optional property applicable only to timelineWeek view that allows to hide the hour cells and only show the day cells.\r\n    *\tProperty type: SchedulerViews | string\r\n    */\n  }, {\n    key: \"views\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.views : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.views = value;\n      }\n    }\n    /** Determines type of the view selector located in the header of the element.\r\n    *\tProperty type: SchedulerViewSelectorType | string\r\n    */\n  }, {\n    key: \"viewSelectorType\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.viewSelectorType : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.viewSelectorType = value;\n      }\n    }\n    /** Determines the Start Date rule. The Week and TimelineWeek views start by default from the current date taking into account the firstDayOfWeek property. When this property is set to 'dateCurrent', these views will start from the value of the 'dateCurrent'.\r\n    *\tProperty type: SchedulerViewStartDay | string\r\n    */\n  }, {\n    key: \"viewStartDay\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.viewStartDay : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.viewStartDay = value;\n      }\n    }\n    /** Determines the format of the week days inside the element.\r\n    *\tProperty type: WeekDayFormat | string\r\n    */\n  }, {\n    key: \"weekdayFormat\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.weekdayFormat : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.weekdayFormat = value;\n      }\n    }\n    /** Determines the format of the dates inside the timeline header when they represent years.\r\n    *\tProperty type: YearFormat | string\r\n    */\n  }, {\n    key: \"yearFormat\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.yearFormat : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.yearFormat = value;\n      }\n    }\n    /** Sets or gets if the element can be focused.\r\n    *\tProperty type: boolean\r\n    */\n  }, {\n    key: \"unfocusable\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.unfocusable : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.unfocusable = value;\n      }\n    }\n    /** Determines the maximum number of redo/undo steps that will be remembered by the Scheduler. When the number is reached the oldest records are removed in order to add new.\r\n    *\tProperty type: number\r\n    */\n  }, {\n    key: \"undoRedoSteps\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.undoRedoSteps : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.undoRedoSteps = value;\n      }\n    }\n    /** A function that can be used to completly customize the popup Window that is used to edit events. The function has the following arguments: target - the target popup Window that is about to be opened.type - the type of the window. The type determines the purpose of the window. The default type is an empty string which means that it's the default event editing window. The other type is 'confirm' ( confirmation window) that appears when clicking on a repeating event. eventObj - the event object that is going to be edited.\r\n    *\tProperty type: any\r\n    */\n  }, {\n    key: \"windowCustomizationFunction\",\n    get: function get() {\n      return this.nativeElement ? this.nativeElement.windowCustomizationFunction : undefined;\n    },\n    set: function set(value) {\n      if (this.nativeElement) {\n        this.nativeElement.windowCustomizationFunction = value;\n      }\n    } // Gets the properties of the React component.\n  }, {\n    key: \"properties\",\n    get: function get() {\n      return [\"autoScrollStep\", \"autoHeightAllDayCells\", \"available\", \"colorScheme\", \"currentTime\", \"currentTimeIndicator\", \"currentTimeIndicatorInterval\", \"contextMenuDataSource\", \"contextMenuClipboardActions\", \"eventTemplate\", \"eventCollectorTemplate\", \"eventRenderMode\", \"eventTooltipTemplate\", \"cellTemplate\", \"dateCurrent\", \"dataExport\", \"dataSource\", \"dateSelectorFormatFunction\", \"dayFormat\", \"disabled\", \"disableAutoScroll\", \"disableDrag\", \"disableDrop\", \"disableResize\", \"disableSelection\", \"disableWindowEditor\", \"disableContextMenu\", \"disableEventMenu\", \"disableViewMenu\", \"disableDateMenu\", \"dragFeedbackFormatFunction\", \"dragOffset\", \"filter\", \"filterable\", \"filterMode\", \"events\", \"firstDayOfWeek\", \"footerTemplate\", \"groupByDate\", \"groupOrientation\", \"groupTemplate\", \"groups\", \"hourEnd\", \"hourStart\", \"hourFormat\", \"headerTemplate\", \"headerDatePosition\", \"headerNavigationStyle\", \"headerViewPosition\", \"hideAllDay\", \"hideNonworkingWeekdays\", \"hideOtherMonthDays\", \"hideTodayButton\", \"hideViewMenuCheckableItems\", \"hideWeekend\", \"legendLocation\", \"legendPosition\", \"legendLayout\", \"legendLayoutMenuBreakpoint\", \"mouseWheelStep\", \"horizontalScrollBarVisibility\", \"locale\", \"max\", \"maxEventsPerCell\", \"min\", \"messages\", \"minuteFormat\", \"monthFormat\", \"nonworkingDays\", \"nonworkingHours\", \"notificationInterval\", \"resizeHandlesVisibility\", \"resizeInterval\", \"resources\", \"restrictedDates\", \"restrictedHours\", \"restricted\", \"rightToLeft\", \"scrollButtonsPosition\", \"shadeUntilCurrentTime\", \"showLegend\", \"sortBy\", \"sortFunction\", \"sortOrder\", \"spinButtonsDelay\", \"spinButtonsInitialDelay\", \"statuses\", \"theme\", \"timelineHeaderFormatFunction\", \"timelineDayScale\", \"timeRulerTicks\", \"timeZone\", \"timeZones\", \"tooltipDelay\", \"tooltipOffset\", \"verticalScrollBarVisibility\", \"view\", \"viewType\", \"views\", \"viewSelectorType\", \"viewStartDay\", \"weekdayFormat\", \"yearFormat\", \"unfocusable\", \"undoRedoSteps\", \"windowCustomizationFunction\"];\n    } // Gets the events of the React component.\n  }, {\n    key: \"eventListeners\",\n    get: function get() {\n      return [\"onBeginUpdate\", \"onEndUpdate\", \"onChange\", \"onItemChange\", \"onItemChanging\", \"onItemClick\", \"onItemInsert\", \"onItemRemove\", \"onItemUpdate\", \"onViewChange\", \"onViewChanging\", \"onEventShortcutKey\", \"onDateChange\", \"onDragStart\", \"onDragEnd\", \"onDropoverCell\", \"onResizeStart\", \"onResizeEnd\", \"onEditDialogOpening\", \"onEditDialogOpen\", \"onEditDialogClose\", \"onEditDialogClosing\", \"onContextMenuOpening\", \"onContextMenuOpen\", \"onContextMenuClose\", \"onContextMenuClosing\", \"onEventMenuOpening\", \"onEventMenuOpen\", \"onEventMenuClose\", \"onEventMenuClosing\", \"onDateMenuOpen\", \"onDateMenuClose\", \"onViewMenuOpen\", \"onViewMenuClose\", \"onNotificationOpen\", \"onNotificationClose\", \"onCreate\", \"onReady\"];\n    }\n  }]);\n  return Scheduler;\n}(React.Component);\nexport default Scheduler;\nexport { Smart, Scheduler };","map":null,"metadata":{},"sourceType":"module"}